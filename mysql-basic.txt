MySQL (MariaDB) основы

Для работы нужен MySQL и командная строка/PhpMyAdmin

----------------------
1. Скачать Open Server
----------------------
Под Windows можно пользоваться OpenServer, под Linux - XAMPP 

open-server.ru
https://ospanel.io/download/

Скачать и распаковать
Запустить OpenServer с правами администратора
Запустить сам OpenServer (с красного флажка на зеленый)

Зайти в консоль: Дополнительно / Консоль

	mysql -u root -p
	пароль пустой

Примечания:
	Команды заверщаются символом ";", можно делать многострочные команды. 
	Обычно команды пишутся в верхнем регистре, пользовательские данные в нижнем.

-----------
2. Команды
-----------

Просмотр списка баз
	
	SHOW DATABASES;

Создание базы

	CREATE DATABASE test CHARACTER SET utf8 COLLATE utf8_general_ci;

Выбор базы данных для работы

	USE test;

Удаление базы данных

	DROP DATABASE test;

Установить пароль для пользователя	

	SET PASSWORD FOR 'user'@'localhost' = PASSWORD('password');

Создание пользователя
	
	Для создания пользователя нужно указать, какие права и для каких объектов ему нужны.

	GRANT ALL ON test.* TO 'user'@'localhost' IDENTIFIED BY 'password';
	exit;
	mysql -u user -p
	password	

Типы данных

	Существуют числовые типы, строковые типы, и для даты и времени
	Чаще всего используются:
		CHAR(len) - текстовые данные фиксированной длинны
		VARCHAR(len) - текстовые данные переменной длинны
		INT[len] - целые числа
		DECIMAL[M,D] - числа с заданной точностью
		FLOAT[M,D] - с плавающей точкой
		DOUBLE[M,D] - с плавающей точкой дойной точности
		DATE - дата YYYY-MM-DD
		TIME - Время HH:MM:SS
		TIMESTAMP - Время в формате timestamp

Создание таблицы

	CREATE TABLE films (
		id INT UNSIGNED NOT NULL AUTO_INCREMENT,
		name VARCHAR(400) NOT NULL,
		genre VARCHAR(255) NOT NULL,
		duration SMALLINT UNSIGNED NOT NULL DEFAULT 0,
		PRIMARY KEY(id));

Показать таблицы в базе

	SHOW TABLES;

Показать описание таблицы

	DESC films;

Поменять название таблицы

	ALTER TABLE films RENAME movies;

Поменять название столбцов
	
	ALTER TABLE movies CHANGE name title VARCHAR(400) NOT NULL;

Добавить столбец в таблицу (если в запросе слово зарезервировано то писать в обратных кавычках)

	ALTER TABLE movies ADD `release` INT;

Поменять тип данных

	ALTER TABLE movies MODIFY `release` YEAR NOT NULL;

Удалить столбец

	ALTER TABLE movies DROP `release`;

Удалить таблицу
	
	DROP TABLE movies;


Добавление данных
	
	INSERT INTO movies('title', 'genre', 'duration')
	VALUES ('Логан', 'Триллер', 141), ('Престиж', 'Триллер', 125);

Выборка данных

	SELECT * FROM movies WHERE duration > 130;

	В WHERE может быть:
	Сравнения: =, <, >, <=, >=, !=, <>, IS TRUE/FALSE, IS NOT TRUE/FALSE
	Логические: AND, OR, XOR, NOT
	Дополнительные: BETWEEN ... AND ..., IN (), LIKE '%...%'

Изменение данных
	
	UPDATE movies SET `release` = '2017' WHERE title = 'Логан';

Удаление данных

	DELETE FROM movies WHERE id = 2;

----------------------------
4. Проектирование баз данных
----------------------------

Первичный ключ (Primary Key, PK)
	- Должен содержать значение
	- Иметь уникальное значение
	- Значение не должно изменяться

Первичный ключ может быть 
	- Простым (один столбец) 
	- Составным (2 и более столбцов)

Первичный ключ может быть
	- Суррогатным (автоматически сгенерированный id)
	- Естественным (набор из существующих столбцов, обеспечивающий уникальность)

Внешний ключ (Foreign Key, FK) - первичный ключ из другой таблицы (для связи)
Обычно имеет имя: 'название таблицы'_'название первичного ключа'

Отношения между таблицами
	- "Один к одному". Запись из таблицы 1 может быть связана только с одной записью из таблицы 2 и наоборот.
	Пример: Человек и номер СНИЛС
	- "Один ко многим". Запись из таблицы 1 может быть связана с несколькими записями из таблицы 2. Запись из таблицы 2 может быть связана только с одной записью из таблицы 1.
	Пример: Мать и ее дети
	- "Многие ко многим". Запись из таблицы 1 может быть связана с несколькими записями из таблицы 2. Запись из таблицы 2 может быть связана с несколькими записями из таблицы 1.
	Пример: Студенты и преподаватели
	"Многие ко многим" обычно состоит из двух таблиц "один ко многим", объедененными с помощью соеденительной таблицы


Нормализация базы данных
	Это процесс приведения структуры базы данных к определенным правилам.
	Цель нормализации - устранить избыточность и противоречивость информации

	Первая нормальнная форма
		- Каждая ячейка столбца содержит только одно значение
		- Не содержиться повторяющихся значений
		- Используется первичный ключ для идентификации строки

	Вторая нормальная форма
		- Находится в первой нормальной форме
		- Каждый столбец полностью зависит от первичного ключа
		Вторая нормальная форма нарушается только при составных первичных ключах

	Треться нормальная форма
		- Находится во второй нормальной форме
		- Отсутствуют транзитивные зависимости - значение каждого столца зависит только от первичного ключа
		(пример несоблюдения - наличие одновременно столбцов Age и Birthday)

--------------------
Пример нормализации:
--------------------

У нас есть таблица 
	movies(id, title, ganre, duration)

Один фильм может относится сразу к разным жанрам

Нужно сделать две таблицы
	movies(id, title, duration)
	genres(id, genre)

И связать их через связующую таблицу
	movies_genres(movie_id, genre_id)

	CREATE TABLE movies_genres(
		movie_id INT,
		genre_id INT,
		FOREIGN KEY(movie_id) REFERENCES movies(id) ON DELETE CASCADE,
		FOREIGN KEY(genre_id) REFERENCES genres(id) ON DELETE CASCADE,
		PRIMARY KEY(movie_id,genre_id)
		); 

	Опция ON DELETE CASCADE - при удалении id из родительских таблиц данные так-же буду удалены


Когда данные нормализоаны и раазбиты по кучи таблиц, для того чтобы их собрать в одн таблицу, используется JOIN
Есть несколько разновидностей JOIN (в квадратных скобках - необязательные ключивые слова)
	1. [INNER] JOIN
	2. LEFT [OUTER] JOIN
	3. RIGHT [OUTER] JOIN
	4. FULL [OUTER] JOIN

	T1(1, 2, 3)
	T2(A, B, C)
	Связь(2 -> A, 3 -> B)

	1. (2 - A, 3 - B)
	2. (1 - NULL, 2 - A, 3 - B)
	3. (2 - A, 3 - B, NULL - C)
	4. (1 - NULL, 2 - A, 3 - B, NULL - C)

Для примера с movies

	SELECT movies.title, genres.genre
	FROM movies INNER JOIN movies_genres
		ON movies.id = movies_genres.movie_id
		INNER JOIN genres
		ON movies_genres.genre_id = genres.id
	WHERE ...


